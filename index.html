<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <title>Universal Hijri Calendar</title>
      <style>

         :root {
            --bg: #f6f7fb;
            --card: #fff;
            --accent: #1a73e8;
            --muted: #666;
            --cell: 34px;
         }
         body {
            font-family:
               system-ui,
               Segoe UI,
               Roboto,
               Arial;
            margin: 16px;
            background: var(--bg);
            color: #222;
         }
         header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto 12px;
            gap: 12px;
         }
         h1 {
            font-size: 1.05rem;
            margin: 0;
         }
         .controls {
            display: flex;
            gap: 8px;
            align-items: center;
         }
         button {
            background: var(--accent);
            color: #fff;
            border: 0;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
         }
         button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
         }
         #yearLabel {
            font-weight: 700;
            color: var(--muted);
            margin-left: 8px;
         }
         main {
            max-width: 1200px;
            margin: 0 auto;
         }
         .info {
            margin: 8px 0;
            color: var(--muted);
         }
         .gridRow {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
         }
         .month {
            width: 220px;
            background: var(--card);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            border-radius: 6px;
            overflow: hidden;
         }
         .month-header {
            background: var(--accent);
            color: white;
            padding: 6px 8px;
            font-weight: 700;
            text-align: center;
         }
         .month-caption {
            font-size: 0.86rem;
            padding: 6px 8px;
            text-align: center;
            color: #0b3d91;
            font-weight: 600;
         }
         table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
         }
         thead th {
            font-weight: 700;
            padding: 6px 4px;
            background: #eaf2ff;
            color: #0b3d91;
            font-size: 0.78rem;
         }
         td,
         th {
            border: 1px solid #e6eefb;
            width: calc(var(--cell));
            height: var(--cell);
            text-align: center;
            vertical-align: top;
            padding: 2px;
            font-size: 0.82rem;
         }
         .emptyCell {
            background: transparent;
            border: 1px solid transparent;
         }
         .dayCell:hover {
            background: #f0f6ff;
            cursor: pointer;
         }
         footer {
            max-width: 1200px;
            margin: 24px auto;
            text-align: center;
            color: var(--muted);
            font-size: 0.9rem;
         }
         @media (max-width: 1000px) {
            .month {
               width: 45%;
            }
         }
         @media (max-width: 600px) {
            .month {
               width: 100%;
            }
            .gridRow {
               flex-direction: column;
               align-items: center;
            }
         }
         .todayHighlight {
  background: #ffcc00 !important;
  font-weight: bold;
  border: 2px solid #e69500;
}

.infoBox {
  position: fixed;
  right: 20px;
  top: 80px;
  width: 260px;
  background: var(--card);
  border: 1px solid #e6eefb;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  font-size: 0.9rem;
  color: #333;
}

.infoBox h2 {
  margin-top: 0;
  font-size: 1rem;
  color: var(--accent);
}

.infoBox p {
  margin: 6px 0;
}
      </style>
   </head>
   <body>
      <header>
         <h1>Universal Hijri Calendar</h1>
         <div class="controls">
            <button onclick="prevYear()">Prev</button>
            <button onclick="nextYear()">Next</button>
            <input
               type="number"
               id="yearInput"
               min="1"
               max="1600"
               value="1"
               style="width: 70px"
            />
            <button onclick="goToYear()">Go</button>
            <button onclick="highlightToday()">Today</button>

            <span id="yearLabel"></span>
         </div>
      </header>



      <main>
         <div id="calendar"></div>
      </main>

      <aside id="infoBox" class="infoBox">
  <h2>Day Information</h2>
  <p id="infoText">Click a day to see details.</p>
</aside>

      <footer>Made by FAISAL</footer>

      <script>
         const monthNames = [
            "Muharram",
            "Safar",
            "Rabi'ul Awwal",
            "Rabi'ul Akhir",
            "Jumadal Ula",
            "Jumadal Akhira",
            "Rajab",
            "Sha'ban",
            "Ramadan",
            "Shawwal",
            "Dhul Qa'ada",
            "Dhul Hijja",
         ];

         class Utils {
            static LUNAR_CYCLE = 29.53058770576;

            static toReducedAngle(d) {
               d %= 360;
               return d < 0 ? d + 360 : d;
            }
            static toRadians(d) {
               return (d * Math.PI) / 180;
            }

            static toDecimalYear(date) {
               const daysInYear = date.getFullYear() % 4 === 0 ? 366 : 365.2425;
               return (
                  date.getFullYear() + Utils.getDayOfYear(date) / daysInYear
               );
            }

            static getDayOfYear(date) {
               const start = new Date(date.getFullYear(), 0, 0);
               const diff =
                  date -
                  start +
                  (start.getTimezoneOffset() - date.getTimezoneOffset()) *
                     60 *
                     1000;
               return Math.floor(diff / (1000 * 60 * 60 * 24));
            }

            static eachLunarCycle(from, thru) {
               let d = new Date(from);
               const dates = [];
               while (d <= thru) {
                  dates.push(new Date(d));
                  d = new Date(
                     d.getTime() + Utils.LUNAR_CYCLE * 24 * 3600 * 1000,
                  );
               }
               return dates;
            }

            static toK(date) {
               return Math.floor((Utils.toDecimalYear(date) - 2000) * 12.3685);
            }
            static toT(k) {
               return k / 1236.85;
            }
            static toJDE(k, T) {
               return (
                  2451550.09766 +
                  29.530588861 * k +
                  0.00015437 * T * T -
                  0.00000015 * T * T * T +
                  0.00000000073 * T * T * T * T
               );
            }
            static toE(T) {
               return 1 - 0.002516 * T - 0.0000074 * T * T;
            }
            static toM(k, T) {
               return Utils.toReducedAngle(
                  2.5534 +
                     29.1053567 * k -
                     0.0000014 * T * T -
                     0.00000011 * T * T * T,
               );
            }
            static toMPrime(k, T) {
               return Utils.toReducedAngle(
                  201.5643 +
                     385.81693528 * k +
                     0.0107582 * T * T +
                     0.00001238 * T * T * T -
                     0.000000058 * T * T * T * T,
               );
            }
            static toF(k, T) {
               return Utils.toReducedAngle(
                  160.7108 +
                     390.67050284 * k -
                     0.0016118 * T * T -
                     0.00000227 * T * T * T +
                     0.000000011 * T * T * T * T,
               );
            }
            static toO(k, T) {
               return Utils.toReducedAngle(
                  124.7746 -
                     1.56375588 * k +
                     0.0020672 * T * T +
                     0.00000215 * T * T * T,
               );
            }

            static toA(k, T) {
               const angles = [
                  299.77 + 0.107408 * k - 0.009173 * T * T,
                  251.88 + 0.016321 * k,
                  251.83 + 26.651886 * k,
                  349.42 + 36.412478 * k,
                  84.66 + 18.206239 * k,
                  141.74 + 53.303771 * k,
                  207.14 + 2.453732 * k,
                  154.84 + 7.30686 * k,
                  34.52 + 27.261239 * k,
                  207.19 + 0.121824 * k,
                  291.34 + 1.844379 * k,
                  161.72 + 24.198154 * k,
                  239.56 + 25.513099 * k,
                  331.55 + 3.592518 * k,
               ];
               const coeffs = [
                  0.000325, 0.000165, 0.000164, 0.000126, 0.00011, 0.000062,
                  0.00006, 0.000056, 0.000047, 0.000042, 0.00004, 0.000037,
                  0.000035, 0.000023,
               ];
               return angles.reduce(
                  (sum, v, i) =>
                     sum +
                     coeffs[i] *
                        Math.sin(Utils.toRadians(Utils.toReducedAngle(v))),
                  0,
               );
            }

            static toNM(E, Sm, Mm, F, O) {
               Sm = Utils.toRadians(Sm);
               Mm = Utils.toRadians(Mm);
               F = Utils.toRadians(F);
               O = Utils.toRadians(O);
               return (
                  -0.4072 * Math.sin(Mm) +
                  0.17241 * E * Math.sin(Sm) +
                  0.01608 * Math.sin(2 * Mm) +
                  0.01039 * Math.sin(2 * F) +
                  0.00739 * E * Math.sin(Mm - Sm) -
                  0.00514 * E * Math.sin(Mm + Sm) +
                  0.00208 * E * E * Math.sin(2 * Sm) -
                  0.00111 * Math.sin(Mm - 2 * F) -
                  0.00057 * Math.sin(Mm + 2 * F) +
                  0.00056 * E * Math.sin(2 * Mm + Sm) -
                  0.00042 * Math.sin(3 * Mm) +
                  0.00042 * E * Math.sin(Sm + 2 * F) +
                  0.00038 * E * Math.sin(Sm - 2 * F) -
                  0.00024 * E * Math.sin(2 * Mm - Sm) -
                  0.00017 * Math.sin(O) -
                  0.00007 * Math.sin(Mm + 2 * Sm) +
                  0.00004 * Math.sin(2 * Mm - 2 * F) +
                  0.00004 * Math.sin(3 * Sm) +
                  0.00003 * Math.sin(Mm + Sm - 2 * F) +
                  0.00003 * Math.sin(2 * Mm + 2 * F) -
                  0.00003 * Math.sin(Mm + Sm + 2 * F) +
                  0.00003 * Math.sin(Mm - Sm + 2 * F) -
                  0.00002 * Math.sin(Mm - Sm - 2 * F) -
                  0.00002 * Math.sin(3 * Mm + Sm) +
                  0.00002 * Math.sin(4 * Mm)
               );
            }

            static toDeltaT(y) {
               if (y < -500) {
                  return -20 + 32 * Math.pow((y - 1820) / 100, 2);
               } else if (y > -500 && y <= 500) {
                  return (
                     10583.6 -
                     1014.41 * (y / 100) +
                     33.78311 * Math.pow(y / 100, 2) -
                     5.952053 * Math.pow(y / 100, 3) -
                     0.1798452 * Math.pow(y / 100, 4) +
                     0.022174192 * Math.pow(y / 100, 5) +
                     0.0090316521 * Math.pow(y / 100, 6)
                  );
               } else if (y > 500 && y <= 1600) {
                  return (
                     1574.2 -
                     556.01 * ((y - 1000) / 100) +
                     71.23472 * Math.pow((y - 1000) / 100, 2) +
                     0.319781 * Math.pow((y - 1000) / 100, 3) -
                     0.8503463 * Math.pow((y - 1000) / 100, 4) -
                     0.005050998 * Math.pow((y - 1000) / 100, 5) +
                     0.0083572073 * Math.pow((y - 1000) / 100, 6)
                  );
               } else if (y > 1600 && y <= 1700) {
                  return (
                     120 -
                     0.9808 * (y - 1600) -
                     0.01532 * Math.pow(y - 1600, 2) +
                     Math.pow(y - 1600, 3) / 7129
                  );
               } else if (y > 1700 && y <= 1800) {
                  return (
                     8.83 +
                     0.1603 * (y - 1700) -
                     0.0059285 * Math.pow(y - 1700, 2) +
                     0.00013336 * Math.pow(y - 1700, 3) -
                     Math.pow(y - 1700, 4) / 1174000
                  );
               } else if (y > 1800 && y <= 1860) {
                  return (
                     13.72 -
                     0.332447 * (y - 1800) +
                     0.0068612 * Math.pow(y - 1800, 2) +
                     0.0041116 * Math.pow(y - 1800, 3) -
                     0.00037436 * Math.pow(y - 1800, 4) +
                     0.0000121272 * Math.pow(y - 1800, 5) -
                     0.0000001699 * Math.pow(y - 1800, 6) +
                     0.000000000875 * Math.pow(y - 1800, 7)
                  );
               } else if (y > 1860 && y <= 1900) {
                  return (
                     7.62 +
                     0.5737 * (y - 1860) -
                     0.251754 * Math.pow(y - 1860, 2) +
                     0.01680668 * Math.pow(y - 1860, 3) -
                     0.0004473624 * Math.pow(y - 1860, 4) +
                     Math.pow(y - 1860, 5) / 233174
                  );
               } else if (y > 1900 && y <= 1920) {
                  return (
                     -2.79 +
                     1.494119 * (y - 1900) -
                     0.0598939 * Math.pow(y - 1900, 2) +
                     0.0061966 * Math.pow(y - 1900, 3) -
                     0.000197 * Math.pow(y - 1900, 4)
                  );
               } else if (y > 1920 && y <= 1941) {
                  return (
                     21.2 +
                     0.84493 * (y - 1920) -
                     0.0761 * Math.pow(y - 1920, 2) +
                     0.0020936 * Math.pow(y - 1920, 3)
                  );
               } else if (y > 1941 && y <= 1961) {
                  return (
                     29.07 +
                     0.407 * (y - 1950) -
                     Math.pow(y - 1950, 2) / 233 +
                     Math.pow(y - 1950, 3) / 2547
                  );
               } else if (y > 1961 && y <= 1986) {
                  return (
                     45.45 +
                     1.067 * (y - 1975) -
                     Math.pow(y - 1975, 2) / 260 -
                     Math.pow(y - 1975, 3) / 718
                  );
               } else if (y > 1986 && y <= 2005) {
                  return (
                     63.86 +
                     0.3345 * (y - 2000) -
                     0.060374 * Math.pow(y - 2000, 2) +
                     0.0017275 * Math.pow(y - 2000, 3) +
                     0.000651814 * Math.pow(y - 2000, 4) +
                     0.00002373599 * Math.pow(y - 2000, 5)
                  );
               } else if (y > 2005 && y <= 2050) {
                  return (
                     62.92 +
                     0.32217 * (y - 2000) +
                     0.005589 * Math.pow(y - 2000, 2)
                  );
               } else if (y > 2050 && y <= 2150) {
                  return (
                     -20 +
                     32 * Math.pow((y - 1820) / 100, 2) -
                     0.5628 * (2150 - y)
                  );
               } else if (y > 2150 && y <= 3000) {
                  return -20 + 32 * Math.pow((y - 1820) / 100, 2);
               } else {
                  // This corresponds to the default case `_ => 0.0`
                  return 0.0;
               }
            }

            static fromJulian(j) {
               const J1970 = 2440587.5; // Julian date for Unix epoch (1970-01-01 UTC)
               const millisecondsInDay = 86400000; // 24 * 60 * 60 * 1000

               const unix = j - J1970;
               return new Date(unix * millisecondsInDay);
            }

            static toDateTimeUTC(correctedJDE) {
const d = Utils.fromJulian(correctedJDE);   // same as Astro.FromJulian in your C#
    const deltaT = Utils.toDeltaT(d.getUTCFullYear()); // ΔT in seconds, depends on year
    return new Date(d.getTime() - deltaT * 1000); // subtract ΔT to get UTC
            }
         }

         // --- Generate New Moons 2020-2025 ---
         const start = new Date(622, 7, 1);
         const end = new Date(2200, 4, 15);

         const approxLunarDates = Utils.eachLunarCycle(start, end);

         const newMoons = approxLunarDates.map((d) => {
            const k = Utils.toK(d),
               T = Utils.toT(k),
               JDE = Utils.toJDE(k, T),
               E = Utils.toE(T),
               Sm = Utils.toM(k, T),
               Mm = Utils.toMPrime(k, T),
               F = Utils.toF(k, T),
               O = Utils.toO(k, T),
               A = Utils.toA(k, T),
               NM = Utils.toNM(E, Sm, Mm, F, O),
               correctedJDE = JDE + NM + A;

            return Utils.toDateTimeUTC(correctedJDE);
         });

         function daysBetween(first, second) {
            // Copy date parts of the timestamps, discarding the time parts.
            var one = new Date(
               first.getFullYear(),
               first.getMonth(),
               first.getDate(),
            );
            var two = new Date(
               second.getFullYear(),
               second.getMonth(),
               second.getDate(),
            );

            // Do the math.
            var millisecondsPerDay = 1000 * 60 * 60 * 24;
            var millisBetween = two.getTime() - one.getTime();
            var days = millisBetween / millisecondsPerDay;

            // Round down.
            return Math.floor(days);
         }

         function generateLunarCalendar(moons) {
            return moons.slice(0, moons.length - 1).map((nm, i) => {
               const start = new Date(nm.getTime());
               const next = new Date(moons[i + 1].getTime());
               const daysInMonth = daysBetween(start, next);
               let days = [];
               for (let d = 1; d <= daysInMonth; d++) {
                  let g = new Date(start.getTime());
                  g.setUTCDate(start.getUTCDate() + d);
                  days.push({ day: d, g: g.toISOString().split("T")[0] });
               }
               return { monthNumber: i % 12, days };
            });
         }

         // Prepare data
         const moons = newMoons;
         const lunarMonths = generateLunarCalendar(moons);
         let lunarData = {},
            y = 1;
         for (let i = 0; i < lunarMonths.length; i += 12) {
            lunarData[y] = lunarMonths.slice(i, i + 12);
            y++;
         }

         let currentYear = 1;

         function renderYear(year) {
            let totalDays = lunarData[year].reduce(
               (sum, m) => sum + m.days.length,
               0,
            );
            document.getElementById("yearLabel").textContent =
               "Year " + year + " (" + totalDays + " days)";
            document.getElementById("yearInput").value = year;
            const cont = document.getElementById("calendar");
            cont.innerHTML = "";

            for (let rowStart = 0; rowStart < 12; rowStart += 4) {
               // 4 months per row
               const grid = document.createElement("div");
               grid.className = "gridRow";
               for (let m = rowStart; m < Math.min(rowStart + 4, 12); m++) {
                  const md = document.createElement("div");
                  md.className = "month";
                  const head = document.createElement("div");
                  head.className = "month-header";
                  head.textContent = monthNames[m];
                  md.appendChild(head);

                  // Keep monthDays as is
                  let xxx = lunarData[year][m].days;

                  // Use different names for Gregorian range
                  const gregStart = new Date(xxx[0].g);
                  const gregEnd = new Date(xxx[xxx.length - 1].g);
                  const shortMonths = [
                     "Jan",
                     "Feb",
                     "Mar",
                     "Apr",
                     "May",
                     "Jun",
                     "Jul",
                     "Aug",
                     "Sep",
                     "Oct",
                     "Nov",
                     "Dec",
                  ];

                  const caption = document.createElement("div");
                  caption.className = "month-caption";
                  caption.textContent =
                     shortMonths[gregStart.getUTCMonth()] +
                     " " +
                     gregStart.getUTCFullYear() +
                     " – " +
                     shortMonths[gregEnd.getUTCMonth()] +
                     " " +
                     gregEnd.getUTCFullYear();

                  md.appendChild(caption);

                  const table = document.createElement("table");
                  const thead = document.createElement("thead");
                  const hrow = document.createElement("tr");
                  ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].forEach((d) => {
                     let th = document.createElement("th");
                     th.textContent = d;
                     hrow.appendChild(th);
                  });
                  thead.appendChild(hrow);
                  table.appendChild(thead);
                  const tbody = document.createElement("tbody");
                  let monthDays = lunarData[year][m].days;
                  let firstDay = new Date(xxx[0].g).getUTCDay();
                  let row = document.createElement("tr");
                  for (let i = 0; i < firstDay; i++) {
                     let td = document.createElement("td");
                     td.className = "emptyCell";
                     row.appendChild(td);
                  }
                  xxx.forEach((day) => {
                     let td = document.createElement("td");
                     td.className = "dayCell";
                     td.textContent = day.day;
                     td.title = day.g;

td.addEventListener("click", () => {
  updateInfoBox(year, m, day.day, day.g);
});

                     row.appendChild(td);
                     if (row.children.length === 7) {
                        tbody.appendChild(row);
                        row = document.createElement("tr");
                     }
                  });
                  if (row.children.length > 0) tbody.appendChild(row);
                  table.appendChild(tbody);
                  md.appendChild(table);
                  grid.appendChild(md);
               }
               cont.appendChild(grid);
            }
         }

         function prevYear() {
            if (currentYear > 1) {
               currentYear--;
               renderYear(currentYear);
            }
         }
         function nextYear() {
            if (currentYear < Object.keys(lunarData).length) {
               currentYear++;
               renderYear(currentYear);
            }
         }
         function goToYear() {
            const val = parseInt(document.getElementById("yearInput").value);
            if (val >= 1 && val <= Object.keys(lunarData).length) {
               currentYear = val;
               renderYear(currentYear);
            } else alert("Invalid year");
         }

function highlightToday(){
  // Reset previous highlights
  document.querySelectorAll(".todayHighlight").forEach(el => {
    el.classList.remove("todayHighlight");
  });

  const today = new Date();
  const todayStr = today.toISOString().split("T")[0];

  // Find which lunar year contains today's date
  let lunarYear = null;
  for(const y in lunarData){
    if(lunarData[y].some(month => month.days.some(d => d.g === todayStr))){
      lunarYear = parseInt(y);
      break;
    }
  }

  // If found, go to that lunar year
  if(lunarYear){
    currentYear = lunarYear;
    renderYear(currentYear);

    // Highlight after re-render
    const cell = [...document.querySelectorAll(".dayCell")]
                   .find(td => td.title === todayStr);
    if(cell) cell.classList.add("todayHighlight");

  } else {
    // If not found (today outside lunar range),
    // just go to the Gregorian year of today, clipped to available range
    const minYear = 1;
    const maxYear = Object.keys(lunarData).length;
    currentYear = Math.min(Math.max(today.getUTCFullYear() - 622 + 1, minYear), maxYear);
    renderYear(currentYear);
    alert("Today is outside the computed lunar range.\nShowing closest available year: " + currentYear);
  }
}

function updateInfoBox(lunarYear, lunarMonthIndex, lunarDay, gregorianDate){
  const monthName = monthNames[lunarMonthIndex];
  document.getElementById("infoText").innerHTML = `
    <strong>Hijri:</strong> ${lunarYear}-${lunarMonthIndex + 1}-${lunarDay}<br>
    <strong>Gregorian:</strong> ${gregorianDate}
  `;
}

         highlightToday();
      </script>
   </body>
</html>
